<html>
<head>
<title>simplegl demo</title>
<script src="math.js"></script>
<script src="gl.js"></script>
</head>
<body onload="start()" style="background-color: #000000;">
<canvas id="canvas" style="position: absolute; touch-action: none; left: 0px; bottom: 0px;"></canvas>
<script>
var mspf, now, then, delta;
var shader, model;

var keyState = {};
var mouseState = {};
var mouseLook = false, mouseX = 0, mouseY = 0;

function start()
{
	screen.start();
}

var screen =
{
	canvas : document.getElementById("canvas"),
	
	start : function()
	{
		this.gl = this.canvas.getContext("webgl2");
		
		this.camNear = 0.1;
		this.camFar = 100;
		this.camFOVY = 67 * DEGRAD;
		this.camera = new Camera(this.camNear, this.camFar, this.FOVY, 1);
		
		spf = 1 / 60; //60 fps
		then = Date.now() / 1000;
		startTime = then;
		this.resize();
		
		this.gl.enable(this.gl.DEPTH_TEST);
		this.gl.enable(this.gl.BLEND);
		this.gl.enable(this.gl.CULL_FACE);
		this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
		this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
		
		shader = createDefaultShader(this.gl);
		
		var dlight = new DirectionalLight();
		dlight.direction.set(-1, -0.8, -0.2);
		dlight.ambient.set(0.4, 0.4, 0.4);
		dlight.specular.set(V1);
		shader.setUniformDirectionalLightEnable(true);
		shader.setUniformDirectionalLight(dlight);
		
		var mat = new Material();
		var tex = new Texture(this.gl, "bonzi.png");
		mat.ambientTexture = tex;
		mat.diffuseTexture = tex;
		mat.ambientTextureEnable = true;
		mat.diffuseTextureEnable = true;
		
		var vbuf = new Array(24);
		var ibuf = new Array(36);
		
		var hw = 0.5;
		var hh = 0.5;
		var hd = 0.5;
		
		vbuf[ 0] = new Vertex(new Vector3(-hw, -hh,  hd), VZ,  0, 1); //BL  front
		vbuf[ 1] = new Vertex(new Vector3( hw, -hh,  hd), VZ,  1, 1); //BR
		vbuf[ 2] = new Vertex(new Vector3(-hw,  hh,  hd), VZ,  0, 0); //TL
		vbuf[ 3] = new Vertex(new Vector3( hw,  hh,  hd), VZ,  1, 0); //TR
		
		vbuf[ 4] = new Vertex(new Vector3(-hw, -hh, -hd), VNZ, 1, 1); //BR  back
		vbuf[ 5] = new Vertex(new Vector3( hw, -hh, -hd), VNZ, 0, 1); //BL
		vbuf[ 6] = new Vertex(new Vector3(-hw,  hh, -hd), VNZ, 1, 0); //TR
		vbuf[ 7] = new Vertex(new Vector3( hw,  hh, -hd), VNZ, 0, 0); //TL
		
		vbuf[ 8] = new Vertex(new Vector3(-hw, -hh, -hd), VNX, 0, 1); //BL  left
		vbuf[ 9] = new Vertex(new Vector3(-hw, -hh,  hd), VNX, 1, 1); //BR
		vbuf[10] = new Vertex(new Vector3(-hw,  hh, -hd), VNX, 0, 0); //TL
		vbuf[11] = new Vertex(new Vector3(-hw,  hh,  hd), VNX, 1, 0); //TR
		
		vbuf[12] = new Vertex(new Vector3( hw, -hh, -hd), VX,  1, 1); //BR  right
		vbuf[13] = new Vertex(new Vector3( hw, -hh,  hd), VX,  0, 1); //BL
		vbuf[14] = new Vertex(new Vector3( hw,  hh, -hd), VX,  1, 0); //TR
		vbuf[15] = new Vertex(new Vector3( hw,  hh,  hd), VX,  0, 0); //TL
		
		vbuf[16] = new Vertex(new Vector3(-hw,  hh,  hd), VY,  0, 1); //BL  top
		vbuf[17] = new Vertex(new Vector3( hw,  hh,  hd), VY,  1, 1); //BR
		vbuf[18] = new Vertex(new Vector3(-hw,  hh, -hd), VY,  0, 0); //TL
		vbuf[19] = new Vertex(new Vector3( hw,  hh, -hd), VY,  1, 0); //TR
		
		vbuf[20] = new Vertex(new Vector3(-hw, -hh,  hd), VNY, 0, 0); //TL  bottom
		vbuf[21] = new Vertex(new Vector3( hw, -hh,  hd), VNY, 1, 0); //TR
		vbuf[22] = new Vertex(new Vector3(-hw, -hh, -hd), VNY, 0, 1); //BL
		vbuf[23] = new Vertex(new Vector3( hw, -hh, -hd), VNY, 1, 1); //BR
		
		ibuf[ 0] = 0;  ibuf[ 1] = 1;  ibuf[ 2] = 2; //front
		ibuf[ 3] = 3;  ibuf[ 4] = 2;  ibuf[ 5] = 1;
		ibuf[ 6] = 6;  ibuf[ 7] = 5;  ibuf[ 8] = 4; //back
		ibuf[ 9] = 5;  ibuf[10] = 6;  ibuf[11] = 7;
		ibuf[12] = 8;  ibuf[13] = 9;  ibuf[14] = 10; //left
		ibuf[15] = 11; ibuf[16] = 10; ibuf[17] = 9;
		ibuf[18] = 14; ibuf[19] = 13; ibuf[20] = 12; //right
		ibuf[21] = 13; ibuf[22] = 14; ibuf[23] = 15;
		ibuf[24] = 16; ibuf[25] = 17; ibuf[26] = 18; //top
		ibuf[27] = 19; ibuf[28] = 18; ibuf[29] = 17;
		ibuf[30] = 22; ibuf[31] = 21; ibuf[32] = 20; //bottom
		ibuf[33] = 21; ibuf[34] = 22; ibuf[35] = 23;
		
		var mesh = new Mesh(this.gl, vbuf, ibuf);
		var matmesh = new MatMesh(mat, mesh);
		model = new Model(matmesh);
		model.transform.setTranslation(new Vector3(0, 0, -3));
		
		draw();
	},
	
	resize : function()
	{
		this.canvas.width = innerWidth;
		this.canvas.height = innerHeight;
		this.gl.viewport(0, 0, innerWidth, innerHeight);
		this.camera.projection.setPerspective(this.camNear, this.camFar, this.camFOVY, innerWidth / innerHeight);
	}
};

function draw()
{
	requestAnimationFrame(draw);
	now = Date.now() / 1000;
	delta = now - then;
	
	if(delta > spf)
	{
		then = now - (delta % spf);
		
		var gl = screen.gl;
		gl.clearColor(0, 0, 0, 1);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		if(mouseLook) screen.camera.calculateFPSView(keyState, mouseX, mouseY, delta);
		shader.setUniformCamera(screen.camera);
		
		model.transform.rotate(VY, delta * 60 * DEGRAD);
		shader.render(model);
	}
}

document.body.onresize = function()
{
	screen.resize();
}

document.body.oncontextmenu = function()
{
	return false;
}

document.onpointerlockchange = function(e)
{
	keyState = {};
	mouseState = {};
	mouseLook = document.pointerLockElement == screen.canvas;
	
	if(mouseLook)
	{
		screen.camera.prvx = mouseX;
		screen.camera.prvy = mouseY;
	}
};

document.onkeydown = function(e)
{
	keyState[e.key.toLowerCase()] = true;
};

document.onkeyup = function(e)
{
	keyState[e.key.toLowerCase()] = false;
};

screen.canvas.onpointerdown = function(e)
{
	mouseState[e.button] = true;
	
	screen.canvas.requestPointerLock();
	screen.canvas.onpointermove(e);
};

screen.canvas.onpointerup = function(e)
{
	mouseState[e.button] = false;
};

screen.canvas.onpointermove = function(e)
{
	mouseX += e.movementX;
	mouseY += e.movementY;
};

window.onfocus = function()
{
	keyState = {};
	mouseState = {};
};

window.onblur = function()
{
	keyState = {};
	mouseState = {};
};

</script>
</body>
</html>
